@page "/admin/servers/images"

@using System.ComponentModel.DataAnnotations
@using Moonlight.Features.Servers.UI.Components
@using Microsoft.EntityFrameworkCore
@using MoonCore.Abstractions
@using MoonCore.Exceptions

@using Moonlight.Features.Servers.Entities
@using Moonlight.Features.Servers.Helpers
@using Microsoft.AspNetCore.Components.Forms
@using Moonlight.Features.Servers.UI.ImageComponents

@inject Repository<Server> ServerRepository
@inject Repository<ServerImageVariable> VariableRepository
@inject Repository<ServerDockerImage> DockerImageRepository
@inject Repository<ServerImage> ImageRepository

@inject ImageConversionHelper ImageConversionHelper
@inject DownloadService DownloadService
@inject ToastService ToastService
@inject AlertService AlertService
@inject ILogger<Index> Logger

@attribute [RequirePermission(5002)]

<AdminServersNavigation Index="2"/>

<FastCrud TItem="ServerImage"
          Loader="Loader"
          OnConfigure="OnConfigure"
          OnConfigureCreate="OnConfigureForm"
          OnConfigureEdit="OnConfigureForm">
    <View>
        <MCBColumn TItem="ServerImage" Field="@(x => x.Id)" Title="Id" Filterable="true"/>
        <MCBColumn TItem="ServerImage" Field="@(x => x.Name)" Title="Name" Filterable="true">
            <Template>
                <span>@context.Name</span>
            </Template>
        </MCBColumn>
        <MCBColumn TItem="ServerImage" Field="@(x => x.Author)" Title="Author" Filterable="true"/>
        <MCBColumn TItem="ServerImage">
            <Template>
                <div class="text-end">
                    @if (!string.IsNullOrEmpty(context.UpdateUrl))
                    {
                        <a class="me-2" href="#" @onclick:preventDefault @onclick="() => UpdateImage(context)">
                            <i class="bx bx-refresh"></i>
                            Update
                        </a>
                    }

                    @if (!string.IsNullOrEmpty(context.DonateUrl))
                    {
                        <a class="me-2" href="@(context.DonateUrl)" target="_blank">
                            <i class="bx bxs-heart text-danger"></i>
                            Donate
                        </a>
                    }

                    <a href="#" class="me-2" @onclick:preventDefault @onclick="() => Export(context)">
                        <i class="bx bx-download"></i>
                        Export
                    </a>
                </div>
            </Template>
        </MCBColumn>
    </View>
    <ViewToolbar>
        <MCBCustomFileSelect @ref="EggUpload" OnFileSelected="ImportEgg">
            <a class="btn btn-info me-2">
                Import egg
            </a>
        </MCBCustomFileSelect>
        <MCBCustomFileSelect @ref="ImageUpload" OnFileSelected="Import">
            <a class="btn btn-info me-3">
                Import
            </a>
        </MCBCustomFileSelect>
    </ViewToolbar>
</FastCrud>

@code
{
    private FastCrud<ServerImage> Crud;

    private MCBCustomFileSelect ImageUpload;
    private MCBCustomFileSelect EggUpload;

    private IEnumerable<ServerImage> Loader(Repository<ServerImage> repository)
    {
        return repository
            .Get()
            .Include(x => x.DockerImages)
            .Include(x => x.Variables);
    }

    private void OnConfigure(FastCrudConfiguration<ServerImage> configuration)
    {
        configuration.ValidateDelete = image =>
        {
            if (ServerRepository.Get().Any(x => x.Image.Id == image.Id))
                throw new DisplayException("A server using this image exists. Please delete the servers using this image to continue");

            return Task.CompletedTask;
        };

        configuration.CustomDelete = CustomDelete;
    }

    private void OnConfigureForm(FastFormConfiguration<ServerImage> configuration, ServerImage image)
    {
        // General
        configuration.AddProperty(x => x.Name)
            .WithDefaultComponent()
            .WithPage("General")
            .WithValidation(FastFormValidators.Required);

        configuration.AddProperty(x => x.Author)
            .WithDefaultComponent()
            .WithPage("General")
            .WithValidation(FastFormValidators.Required);

        configuration.AddProperty(x => x.DonateUrl)
            .WithDefaultComponent()
            .WithPage("General")
            .WithDescription("Provide a url here in order to give people the ability to donate for your work");

        configuration.AddProperty(x => x.UpdateUrl)
            .WithDefaultComponent()
            .WithPage("General")
            .WithDescription("A http(s) url directly to a json file which will serve as an update for the image. When a update is fetched, it will just get this url and try to load it");

        // Power
        configuration.AddProperty(x => x.StartupCommand)
            .WithDefaultComponent()
            .WithValidation(FastFormValidators.Required)
            .WithPage("Start, Stop & Status")
            .WithDescription("This command will be executed at the start of a server. You can use environment variables in a {} here");

        configuration.AddProperty(x => x.OnlineDetection)
            .WithDefaultComponent()
            .WithValidation(FastFormValidators.Required)
            .WithPage("Start, Stop & Status")
            .WithDescription("A regex string specifying that a server is online when the daemon finds a match in the console output matching this expression");

        configuration.AddProperty(x => x.StopCommand)
            .WithDefaultComponent()
            .WithValidation(FastFormValidators.Required)
            .WithPage("Start, Stop & Status")
            .WithDescription("A command which will be sent to the servers stdin when it should get stopped. Power signals can be achived by using ^. E.g. ^C");
        
        // Parsing
        configuration.AddProperty(x => x.ParseConfiguration)
            .WithComponent<ImageParseConfigEditor>()
            .WithPage("Parsing");

        configuration.AddCustomPage("Variables", ComponentHelper.FromType<ImageVariables>(parameters =>
        {
            parameters.Add("Image", image);
        }));

        configuration.AddCustomPage("Docker Images", ComponentHelper.FromType<ImageDockerImages>(parameters =>
        {
            parameters.Add("Image", image);
        }));

        configuration.AddProperty(x => x.AllowDockerImageChange)
            .WithComponent<SwitchComponent>()
            .WithPage("Miscellaneous")
            .WithDescription("This toggle specifies if a user is allowed to change the docker image from the list of docker images associated to the image");
        
        configuration.AddProperty(x => x.DefaultDockerImage)
            .WithComponent<DefaultDockerImage>(dockerImage =>
            {
                dockerImage.Image = image;
            })
            .WithPage("Miscellaneous");

        configuration.AddProperty(x => x.AllocationsNeeded)
            .WithDefaultComponent()
            .WithPage("Miscellaneous")
            .WithValidation(x => x >= 1 ? ValidationResult.Success : new ValidationResult("This specifies the amount of allocations needed for this image in order to create a server"));

        configuration.AddProperty(x => x.InstallDockerImage)
            .WithDefaultComponent()
            .WithPage("Installation")
            .WithName("Docker Image")
            .WithValidation(FastFormValidators.Required)
            .WithValidation(RegexValidator.Create("^(?:[a-zA-Z0-9\\-\\.]+\\/)?[a-zA-Z0-9\\-]+(?:\\/[a-zA-Z0-9\\-]+)*(?::[a-zA-Z0-9_\\.-]+)?$", "You need to provide a valid docker image name"));

        configuration.AddProperty(x => x.InstallShell)
            .WithDefaultComponent()
            .WithPage("Installation")
            .WithName("Shell")
            .WithValidation(FastFormValidators.Required);

        configuration.AddProperty(x => x.InstallScript)
            .WithComponent<EditorComponent>()
            .WithPage("Installation")
            .WithName("Script")
            .WithValidation(FastFormValidators.Required);
    }

    private Task CustomDelete(ServerImage serverImage)
    {
        var image = ImageRepository
            .Get()
            .Include(x => x.Variables)
            .Include(x => x.DockerImages)
            .First(x => x.Id == serverImage.Id);

        // Cache relational data
        var variables = image.Variables.ToArray();
        var dockerImages = image.DockerImages.ToArray();

        // Unlink data
        image.DockerImages.Clear();
        image.Variables.Clear();

        // Save changes
        ImageRepository.Update(image);

        // Delete variables (errors ignored)
        foreach (var variable in variables)
        {
            try
            {
                VariableRepository.Delete(variable);
            }
            catch (Exception)
            {
                /* this should not fail the operation */
            }
        }

        // Delete docker images (errors ignored)
        foreach (var dockerImage in dockerImages)
        {
            try
            {
                DockerImageRepository.Delete(dockerImage);
            }
            catch (Exception)
            {
                /* this should not fail the operation */
            }
        }

        ImageRepository.Delete(serverImage);

        return Task.CompletedTask;
    }

    private async Task Export(ServerImage image)
    {
        var json = await ImageConversionHelper.ExportAsJson(image);
        var imageName = image.Name.Replace(" ", "");
        await DownloadService.DownloadString($"{imageName}.json", json);

        await ToastService.Success($"Successfully exported '{image.Name}'");
    }

    private async Task Import(IBrowserFile file)
    {
        try
        {
            var stream = file.OpenReadStream();

            using var sr = new StreamReader(stream);
            var content = await sr.ReadToEndAsync();

            var image = await ImageConversionHelper.ImportFromJson(content);

            ImageRepository.Add(image);
            await ToastService.Success($"Successfully imported '{image.Name}'");

            await ImageUpload.RemoveSelection();
            await Crud.Refresh();
        }
        catch (DisplayException)
        {
            throw;
        }
        catch (Exception e)
        {
            Logger.LogWarning("An error occured while importing a image: {e}", e);

            await ToastService.Danger("Unable to import egg: " + e.Message);
        }
        finally
        {
            await ImageUpload.RemoveSelection();
        }
    }

    private async Task ImportEgg(IBrowserFile file)
    {
        await AlertService.Confirm("Import a pterodactyl egg", "Importing pterodactyl eggs is a experimental feature and may result in unusable images. Are you sure you want to proceed?",
            async () =>
            {
                try
                {
                    var stream = file.OpenReadStream();

                    using var sr = new StreamReader(stream);
                    var content = await sr.ReadToEndAsync();

                    var image = await ImageConversionHelper.ImportFromEggJson(content);

                    ImageRepository.Add(image);
                    await ToastService.Success($"Successfully imported '{image.Name}'");

                    await EggUpload.RemoveSelection();
                    await Crud.Refresh();
                }
                catch (DisplayException)
                {
                    throw;
                }
                catch (Exception e)
                {
                    Logger.LogWarning("An error occured while importing a pterodactyl egg: {e}", e);

                    await ToastService.Danger("Unable to import egg: " + e.Message);
                }
                finally
                {
                    await EggUpload.RemoveSelection();
                }
            },
            "Yes, i take the risk");
    }
    
    private async Task UpdateImage(ServerImage image)
    {
        if (string.IsNullOrEmpty(image.UpdateUrl))
            return;
        
        string? httpResult = null;

        if (!await AlertService.YesNo("Are you sure you want to update this image? The process could cause it to break."))
            return;
        
        try
        {
            using (HttpClient httpClient = new HttpClient())
            {
                // pull from update url
                httpResult = await httpClient.GetStringAsync(image.UpdateUrl);
            }
        }
        catch (Exception e)
        {
            throw new DisplayException("An error occured while updating your image: " + e.Message);
        }

        var newImage = await ImageConversionHelper.ImportFromJson(httpResult);
        
        // Update main information
        image.Name = newImage.Name;
        image.Author = newImage.Author;
        image.AllocationsNeeded = newImage.AllocationsNeeded;
        image.DonateUrl = newImage.DonateUrl;
        image.InstallScript = newImage.InstallScript;
        image.InstallShell = newImage.InstallShell;
        image.OnlineDetection = newImage.OnlineDetection;
        image.ParseConfiguration = newImage.ParseConfiguration;
        image.StartupCommand = newImage.StartupCommand;
        image.StopCommand = newImage.StopCommand;
        image.UpdateUrl = newImage.UpdateUrl;
        image.DefaultDockerImage = newImage.DefaultDockerImage;
        image.InstallDockerImage = newImage.InstallDockerImage;
        image.AllowDockerImageChange = newImage.AllowDockerImageChange;

        foreach (var imageVariable in newImage.Variables)
        {
            if (image.Variables.Any(x => x.Key == imageVariable.Key))
            {
                int index;

                try
                {
                    index = image.Variables.FindIndex(x => x.Key == imageVariable.Key);
                }
                catch
                {
                    return;
                }
                
                // List.FindIndex returns -1 if the item was not found
                if (index == -1)
                    return;

                image.Variables[index].DefaultValue = imageVariable.DefaultValue;
                image.Variables[index].DisplayName = imageVariable.DisplayName;
                image.Variables[index].Description = imageVariable.Description;
                image.Variables[index].AllowView = imageVariable.AllowView;
                image.Variables[index].AllowEdit = imageVariable.AllowEdit;
                image.Variables[index].Filter = imageVariable.Filter;
            }
            else
            {
                image.Variables.Add(imageVariable);
            }
        }
        
        // Remove unused Variables: (hashset for faster lookup)
        HashSet<string> newKeys = new(newImage.Variables.Select(x => x.Key));
        image.Variables.RemoveAll(x => !newKeys.Contains(x.Key));
        
        foreach (var dockerImage in newImage.DockerImages)
        {
            if (image.DockerImages.Any(x => x.Name == dockerImage.Name))
            {
                int index;

                try
                {
                    index = image.DockerImages.FindIndex(x => x.Name == dockerImage.Name);
                }
                catch
                {
                    return;
                }
                
                // List.FindIndex returns -1 if the item was not found
                if (index == -1)
                    return;

                image.DockerImages[index].DisplayName = dockerImage.DisplayName;
                image.DockerImages[index].AutoPull = dockerImage.AutoPull;
                
            }
            else
            {
                image.DockerImages.Add(dockerImage);
            }
        }
        
        // Remove unused DockerImages: (hashset for faster lookup)
        HashSet<string> newDockerImageNames = new(newImage.DockerImages.Select(x => x.Name));
        image.DockerImages.RemoveAll(x => !newDockerImageNames.Contains(x.Name));
        
        ImageRepository.Update(image);

        await Crud.Reload();
        await ToastService.Success("Successfully updated image \"" + image.Name + "\"!");
    }
}